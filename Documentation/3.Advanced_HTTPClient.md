# Advanced HTTP Client

- [Advanced HTTP Client](#advanced-http-client)
  - [Why using a custom HTTPClient](#why-using-a-custom-httpclient)
  - [Validate Responses: Validators](#validate-responses-validators)
    - [Approve the response](#approve-the-response)
    - [Fail with error](#fail-with-error)
    - [Retry with strategy](#retry-with-strategy)

## Why using a custom HTTPClient

When your app is complex and you need to manage different http webservices, or you want to avoid using the shared client to create a decupled implementation, creating a custom `HTTPClient` is the best thing you can do.

With a custom `HTTPClient` you can define your own rules to validate a response coming from a particular webservices, handling all the particular responses and edge cases you can encounter.

This is a custom client:

```swift
public lazy var b2cClient: HTTPClient = {
    var config = URLSessionConfiguration.default
    config.httpShouldSetCookies = true
    config.networkServiceType = .responsiveData
        
    let client = HTTPClient(baseURL: "https://myappb2c.ws.org/api/v2/",configuration: config)

    // Setup some common HTTP Headers for all requests
    client.headers = HTTPHeaders([
        .init(name: .userAgent, value: myAgent),
        .init(name: "X-API-Experimental", value: "true")
    ])
        
    return client
}()
```

It contains a particular `URLSessionConfiguration` and a set of common HTTP Headers which are automatically used by any `HTTPRequest` you run in.

## Validate Responses: Validators

Each raw response from a network call can be validated by a set of objects conform to the `HTTPValidator` object.  

`HTTPClient` instances has a `validators` array which may contains an ordered list of validators which respond to this method:

```swift
func validate(response: HTTPResponse, forRequest request: HTTPRequest) -> HTTPResponseValidatorResult { }
```

This function analyze the response coming from request and decide the next step.  
Particularly you can return:

### Approve the response
`nextValidator`  
The response is okay, you can move to the next validator (if any) or return the response received by the server.

### Fail with error

`failChain(Error)`  
Received response is not valid (for example you have an `error` node in your json response which indicates the failure). You can parse the response and return a custom error bypassing the initial response.

### Retry with strategy
`retry(HTTPRetryStrategy)`  
Something bad has occurred; you can however retry if `maxRetries` of the `HTTPRequest` is > 1.  
The options are: 
- `immediate` (will retry the original call immediately)
- `delayed` (will retry the original call after a given amount of seconds), 
- `exponential` and `fibonacci` (same of the `delayed` with different time based upon the attempt made)
- `after(HTTPRequest, TimeInterval, AltRequestCatcher?)` retry the original call after calling an alternate request. For example you are making an authenticated request and session has expired; you can therefore call a login alt request to perform a new login and retry the original call.
   
