# Build A Request

RealHTTP offer a type-safe, perfectly Swift integrated way to build and configure a new http request.  

At the simplest you just need to provide a valid url both as `URL` or `String` (conversion happens automatically):

```swift
let todo = try await HTTPRequest("https://jsonplaceholder.typicode.com/todos/1")
                     .fetch(Todo.self)
```

The following code build a `GET` `HTTPRequest` and execute it into the `shared` `HTTPClient`Â instance.  
The result is therefore converted to `Codable` conform's `Todo` object.  
All asynchronously, all in a one line of code.

However not all requests are so simple; you may need to configure parameters, headers and the body, along with some other settings like timeout or retry/cache strategies.   
We'll look at this below.

## Initialize a Request

You have three different convenience ways to create a new request depending how many settings you would to change.

### Standard

You can use this method when your configuration is pretty simple, just the HTTP method and the absolute URL.  
This example create a post to add a new todo in [jsonplaceholder](https://jsonplaceholder.typicode.com) site using automatic json conversion *(you will learn more about body encoding below)*.

```swift
let req = try HTTPRequest(method: .post, "https://jsonplaceholder.typicode.com/posts",
                          body: try .json(["title": "foo", "body": "bar", "userId": 1]))
let _ = try await req.fetch()
```

### URI Template

RealHTTP also allows to create a request via URI Template as specified by [RFC6570](https://tools.ietf.org/html/rfc6570) using the [Kylef](https://github.com/kylef/URITemplate.swift) Swift implementation.  
A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion.  

```swift
let req = try HTTPRequest(URI: "https://jsonplaceholder.typicode.com/posts/{postId}", 
                          variables: ["postId": 1])
let _ = try await req.fetch()
```

### Builder Pattern

The most complete way to configure a request is by using the builder pattern initialization. It allows you to specify any property of the `HTTPRequest` inside a callback function which encapsulate and make clear the init process.

```swift
let req = HTTPRequest {
    // Setup default params
    $0.url = URL(string: "https://.../login")!
    $0.method = .get
    $0.timeout = 100

    // Setup some additional settings
    $0.redirectMode = redirect
    $0.maxRetries = 4
    $0.allowsCellularAccess = false
            
    // Setup URL query params & body
    $0.addQueryParameter(name: "full", value: "1")
    $0.addQueryParameter(name: "autosignout", value: "30")
    $0.body = .json(["username": username, "pwd": pwd])
}
let _ = try await req.fetch()
```
You can configure the behaviour and settings of your request directly inside the callback as showed above. 

## HTTP Client

Once you have configured a request you're ready to execute it.  
In order to be executed request must be passed to a clien. The class `HTTPClient` represent a container of common configuration settings which can manage a session.  

For example a client can be configured to use a base URL for each request (you will not set the `url` inside the request configuration, just the `path`), to send a common set of headers for each request executed.  
It also managed received/sent cookie.  
Under the hood the client is a queue so you can also set the maximum number of concurrent connections (if not specified the OS will do it accordlying to the available resources).

### Shared Client

`HTTPClient.shared` is the shared client. No `baseURL` is set for shared client so your request must contains the absolute url (via `url` parameter) in order to be executed correctly.  
When you call `fetch()` function without passing a client the shared client is used.

```swift
// Full URL is required to execute request in shared client
let req = try HTTPRequest(method: .post, "https://jsonplaceholder.typicode.com/posts")
let _ = try await req.fetch() // if not specified, HTTPClient.shared is used
```

### Custom Client

Sometimes you need to take more control about your client or you just need to isolate specific application logic.  
For example we're using different clients based upon our app is communicating with B2B or B2C web services.  
This allows us to have a fine grained control over our settings (cookies, session management, concurrent operations and more).

The following example create a new client with some settings:

```swift
public lazy var b2cClient: HTTPClient = {
    var config = URLSessionConfiguration.default
    config.httpShouldSetCookies = true
    config.networkServiceType = .responsiveData
        
    let client = HTTPClient(baseURL: "https://myappb2c.ws.org/api/v2/",configuration: config)
    client.headers = HTTPHeaders([
        .init(name: .userAgent, value: myAgent),
        .init(name: "X-API-Experimental", value: "true")
    ])
        
    return client
}()
```
Now we can use it to perform a new request:

```swift
let loginCredentials = UserCred(username: "..." pwd: "...") // Encodable conform
let req = HTTPRequest {
    $0.path = "login" // full url will be b2cClient.baseURL + path
    $0.method = .post
    $0.addQueryParameter(name: "autosignout", value: "30")
    $0.body = .json(loginCredentials) // automatic conversion to json in body
}

// URL is: https://myappb2c.ws.org/api/v2/login?autosignout=30
// Execute async request and decode the response to LoggedUser object (Codable).
let user = req.fetch(b2cClient).decode(LoggedUser.self)
```

## Execute a Request

As you seen above, executing an asynchronous request is easy as calling its `fetch()` method.  
This is an `async` `throwable` method so you need to call it in an async scope.  
This is just an example which uses the `Task` and `@MainActor` to execute an async request and update the UI on main thread:

```swift
let task = detach {
    do {
        let user = req.fetch(b2cClient).decode(LoggedUser.self)
        self.updateUserProfile(.success(user))
    } catch {
        self.updateUserProfile(.failure(error))
    }
}

@MainActor
private func updateUserProfile(_ data: Result<LoggedUser,Error>) {
    // executed on main thread
}
```

These stuff are not related to the http library so we'll suggest looking at some @MainActor docs ([here](https://www.swiftbysundell.com/articles/the-main-actor-attribute/), [here](https://developer.apple.com/documentation/swift/mainactor) or [here](https://www.avanderlee.com/swift/mainactor-dispatch-main-thread/)).

